.ZVERSION 3

.ZHEADER StatLineType 0
.ZHEADER StoryfileSplit 0
.ZHEADER Tandy 0
.ZHEADER ReleaseNumber 0x42
.ZHEADER SerialNum C"421337"
.ZHEADER CompilerVer 0x1337
.ZHEADER InitialPC15 entry

.OBJECTS
.PROPERTY 1  1, 0
.PROPERTY 15 255, 128
.OBJECT "HELLO" {
	.ATTRIBUTE 0
	.ATTRIBUTE 4
	
	.PROPERTY 1 C"Hello"
	.PROPERTY 2 "to,ke ns"
	.OBJECT "WORLD" {
		.PROPERTY 15 0, 0
		.PROPERTY 1 C"World"
	}
	.OBJECT "!" {
		.PROPERTY 1 C"!"
	}
}

.GLOBALS
.GLOBAL bsdf entry
.GLOBAL csdf 0
.GLOBAL dsdf

.BUFFER 16 BYTE testbuffer1
.VALUE testbuffer2Size 64
.BUFFER testbuffer2Size BYTE testbuffer2 "This is the buffer content.\n"

.SECTION static

.DICTIONARY '.' ',' '"'
.KEY "mail"
.DATA 1 BYTE 00
.KEY "door"
.DATA 1 BYTE 00
.KEY "hit"
.DATA 1 BYTE 01
.DATA 2 BYTE testroutine


entry:
verify ? checksum_match
print "checksum wrong!\n"
// Unfortunately, the unconditional branch is asinine to use.
jz 0 ? checksum_after
checksum_match:
print "checksum verified!\n"
checksum_after:
call testroutine -> sp
print_obj 1
print "\n"

test_attr 1, 4 ? attr4_set
print "obj1.attribute4 is unset! (incorrect)\n"
jz 0 ? attr4_after
attr4_set:
print "obj1.attribute4 is set! (correct)\n"
attr4_after:

test_attr 1, 2 ? attr2_set
print "obj1.attribute2 is unset! (correct)\n"
jz 0 ? attr2_after
attr2_set:
print "obj1.attribute2 is set! (incorrect)\n"
attr2_after:

.MACRO testmacro
.MACROPARAM theparam
.MACROPARAM scratchreg1
.MACROPARAM scratchreg2
print "Macro called with arg "
print_num ..theparam
new_line
add 0, ..theparam -> ..scratchreg1
loop:
call localroutine -> ..scratchreg2
sub ..scratchreg1, 1 -> ..scratchreg1
jg ..scratchreg1, 0 ?loop
new_line
jg 1, 0 ?afterlocalroutine

.ROUTINE localroutine
print "Loop"
rtrue

afterlocalroutine:
.ENDMACRO

print "before macro calls"
new_line
add 0, 2 -> g1
.testmacro 1, g0, g2
.testmacro g1, g0, g2
.testmacro 3, g0, g1

.MACRO innermacro
.MACROPARAM a
print_num ..a + 1
new_line
.ENDMACRO
.MACRO outermacro
.MACROPARAM a
.innermacro ..a * 2
.ENDMACRO
// This should print 11.
.outermacro 5

call testproperties -> sp
call testbuffer -> sp

quit

// In practice, it's nonsensical why code should be before the high memory mark - this is just for testing.
// Code before the high memory mark shouldn't cause problems, so no diagnostic is expected.
.SECTION high

.ROUTINE testroutine
.LOCAL asdf
print "Hello from testroutine!\n"
rtrue

.ROUTINE testproperties
.LOCAL prop
.LOCAL child
get_prop 1, 15 -> l0
jz l0 ? obj1prop1_zero
print "obj1.prop1 is not zero (correct)\n"
jz 0 ? obj1prop1_end
obj1prop1_zero:
print "obj1.prop1 is zero (incorrect)\n"
obj1prop1_end:

get_child 1 -> l1 ? has_child
print "obj1 has no child (incorrect)\n"
rtrue
has_child:
print "obj1 has a child (correct)\n"

get_prop l1, 15 -> l0
jz l0 ? child1prop1_zero
print "obj1.child1.prop1 is not zero (incorrect)\n"
jz 0 ? child1prop1_end
child1prop1_zero:
print "obj1.child1.prop1 is zero (correct)\n"
child1prop1_end:
rtrue

.ROUTINE testbuffer
print "Trying to print buffer content...\n"
print_addr testbuffer2
rtrue
